> داده‌ها به‌صورت بلوکی بین دیسک‌ها **Striping** می‌شن  
> و **دو لایه‌ی parity (دو مجموعه بیت توازن)** برای هر بلوک ذخیره می‌شن  
> این parityها به‌صورت **توزیع‌شده بین همه دیسک‌ها** ذخیره می‌شن  
> → نتیجه: **تحمل خرابی همزمان ۲ دیسک**
### عملکرد خواندن و نوشتن:

| عملیات            | رفتار در RAID 6                                                                                                     |
| ----------------- | ------------------------------------------------------------------------------------------------------------------- |
| **خواندن (Read)** | سریع و موازی؛ مشابه RAID 5، چون داده‌ها بین دیسک‌ها توزیع شده و موازی‌خوانی ممکنه                                   |
| **نوشتن (Write)** | کندتر از RAID 5؛ چون علاوه بر داده، باید **دو parity** محاسبه و نوشته شود → نیاز به CPU بیشتر و ترافیک نوشتن بالاتر |
### نتیجه:

- خواندن‌ها همچنان سریع هستند
    - نوشتن‌ها کندتر از RAID 5 به دلیل محاسبه‌ی **دو parity (dual parity)**
    - مناسب برای سیستم‌هایی با حجم زیاد دیسک یا کاربردهای حساس به از دست رفتن داده
    → RAID 6 در مقایسه با RAID 5، امنیت بیشتری ارائه می‌ده ولی با **هزینه‌ی بیشتر روی سرعت نوشتن**
### مشکل بالقوه RAID 6:

> عملیات نوشتن سنگین‌تر است و محاسبه‌ی dual parity می‌تونه فشار روی CPU یا RAID controller بیاره  
> در سیستم‌هایی با دیسک‌های زیاد و ترافیک بالا، بهتره از RAID سخت‌افزاری یا caching استفاده بشه

### ظرفیت قابل استفاده:

> برابر است با:  
> `ظرفیت دیسک کوچک‌تر × (تعداد دیسک‌ها - 2)`
مثلاً اگر ۶ دیسک ۲ ترابایتی داشته باشیم:
`(2TB × 4) = 8TB usable`



### مثال

| Disk A | Disk B | Disk C | Disk D | Disk E |
| ------ | ------ | ------ | ------ | ------ |
| D1     | D2     | D3     | P1     | Q1     |
داده‌ها (۴ بیت):

```
D1 = 1101  
D2 = 1010  
D3 = 0110
```
### محاسبه‌ی P1 (XOR parity):

```
P1 = D1 ⊕ D2 ⊕ D3  
   = 1101 ⊕ 1010 = 0111  
   = 0111 ⊕ 0110 = 0001
```

P1 = `0001`
### محاسبه‌ی Q1 (وزن‌دهی ساده):

```
فرض: Q1 = D1 × 1 ⊕ D2 × 2 ⊕ D3 × 3  
       = D1 ⊕ (D2 << 1) ⊕ (D3 << 2)

D2 << 1 = 0100  
D3 << 2 = 1000

Q1 = 1101 ⊕ 0100 = 1001  
Q1 = 1001 ⊕ 1000 = 0001
```

Q1 = `0001`

### خرابی: Disk B و Disk E

موجود داریم: D1، D3، P1

بازسازی D2:

```
D2 = P1 ⊕ D1 ⊕ D3  
   = 0001 ⊕ 1101 = 1100  
   = 1100 ⊕ 0110 = 1010
```

D2 = `1010` (بازسازی شد)

Q1 نیز قابل محاسبه مجدد است.


## برای حالتی که دوتا دیسک هم از بین بروند اوکی هستش اما به علت ریاضیات پیچیده دیگه مثالش نیاوردم.